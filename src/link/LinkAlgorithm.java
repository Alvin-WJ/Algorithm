package link;

public class LinkAlgorithm {

	/**
	 * 有一个单向链表，链表当中有可能出现“环”。如何用程序判断出这个链表是有环链表？
	 */
	// 首先创建一个以节点ID为键的HashSet集合，用来存储曾经遍历过的节点。然后同样是从头节点开始，依次遍历单链表的每一个节点。每遍历到一个新节点，就用新节点和HashSet集合当中存储的节点作比较，如果发现HashSet当中存在相同节点ID，则说明链表有环，如果HashSet当中不存在相同的节点ID，就把这个新节点ID存入HashSet，之后进入下一节点，继续重复刚才的操作。
	public boolean test1(Node root) {
		return true;
	}

	/**
	 * 有一个单向链表，链表当中有可能出现“环”。如何用程序判断出这个链表是有环链表？
	 */
	//快慢指针
	// 首先创建两个指针1和2（在java里就是两个对象引用），同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针1每次向下移动一个节点，让指针2每次向下移动两个节点，然后比较两个指针指向的节点是否相同。如果相同，则判断出链表有环，如果不同，则继续下一次循环。
	// 例如链表A->B->C->D->B->C->D，两个指针最初都指向节点A，进入第一轮循环，指针1移动到了节点B，指针2移动到了C。第二轮循环，指针1移动到了节点C，指针2移动到了节点B。第三轮循环，指针1移动到了节点D，指针2移动到了节点D，此时两指针指向同一节点，判断出链表有环。
	// 此方法也可以用一个更生动的例子来形容：在一个环形跑道上，两个运动员在同一地点起跑，一个运动员速度快，一个运动员速度慢。当两人跑了一段时间，速度快的运动员必然会从速度慢的运动员身后再次追上并超过，原因很简单，因为跑道是环形的。
	public boolean test2(Node node) {
		return true;
	}

	/**
	 * 判断两个链表是否相交，如果相交找出他们的交点。
	 */
	// 把第一个链表每个节点放进hash表，遍历第二个链表的每个节点，判断是否在hash表中存在
	public Node test3() {
		return null;
	}

	/**
	 * 判断两个链表是否相交
	 */
	// 先遍历第一个链表到他的尾部，然后将尾部的next指针指向第二个链表(尾部指针的next本来指向的是null)。这样两个链表就合成了一个链表，判断原来的两个链表是否相交也就转变成了判断新的链表是否有环的问题了
	// 仔细研究两个链表，如果他们相交的话，那么他们最后的一个节点一定是相同的，否则是不相交的。因此判断两个链表是否相交就很简单了，分别遍历到两个链表的尾部，然后判断他们是否相同，如果相同，则相交；否则不相交。
	public Node test4() {
		return null;
	}

	/**
	 * 判断两个链表是否相交，如果相交找出他们的第一个交点。
	 * 
	 * 一般答案：用两个辅助栈，分别把两个节点的元素放入两个栈中。栈是先入后出。
	 *       那么pop栈的动作就是从链表尾部开始，两个栈同时pop，最后一个相同的元素，就是第一个交点
	 *
	 * 完美答案：遍历两个链表，第一个长度是m，第二个长度是n，找到较长的那个链表，例如是m，
	 *   让m先遍历m-n个元素，然后从第一个链表的第m-n个元素，和第二个链表的第0个元素，同时遍历，直到找到第一个相同的元素
	 *
	 */
	public Node test5() {
		return null;
	}
	
	/**
	 * 问题：数组中两个数字如果前面数字大于后面数字，这就是逆序对。问一个数组中有多少个逆序对
	 *
	 * 思路：归并排序，将数组递归的拆分，然后在merge合并
	 */
	public Node test6(int[] nums) {
		return null;
	}

	public class Node {

		int data;
		Node next;

		public Node(int data) {
			this.data = data;
		}

		public String toString() {
			return String.valueOf(data);
		}
	}
}
